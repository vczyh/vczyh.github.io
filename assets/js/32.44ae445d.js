(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{514:function(_,v,t){"use strict";t.r(v);var d=t(4),a=Object(d.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h3",{attrs:{id:"无关性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无关性"}},[_._v("#")]),_._v(" 无关性")]),_._v(" "),t("ul",[t("li",[_._v("平台无关：在源代码和机器指令添加了一层字节码指令")]),_._v(" "),t("li",[_._v("语言无关：只要编译后的文件符合class文件规范均可以在jvm上运行")])]),_._v(" "),t("h3",{attrs:{id:"class类文件结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class类文件结构"}},[_._v("#")]),_._v(" Class类文件结构")]),_._v(" "),t("ul",[t("li",[_._v("Class文件是以字节为单位的二进制流，各个数据项目中间没有添加任何分隔符，紧凑的排列在文件中")]),_._v(" "),t("li",[_._v("当遇到需要占用八个字节以上空间的数据项时，则会按照高位在前（数据高位存储在地址低位）的方式分割成若干个字节进行存储")]),_._v(" "),t("li",[_._v("Class只有俩种数据类型：\n"),t("ul",[t("li",[_._v("无符号数：u1、u2、u4、u8分别代表1个字节、2个字节、4个字节、8个字节的无符号数")]),_._v(" "),t("li",[_._v("表：由多个无符号数或者其他表作为数据项构成的复合数据类型")])])])]),_._v(" "),t("h4",{attrs:{id:"魔数与class文件的版本"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#魔数与class文件的版本"}},[_._v("#")]),_._v(" 魔数与Class文件的版本")]),_._v(" "),t("ul",[t("li",[_._v("魔数：唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件，比文件后缀名更具有标识性。Class文件的魔数取得很有浪漫气息，值为0xCAFEBABE（咖啡宝贝），魔数占4个字节。")]),_._v(" "),t("li",[_._v("次版本号：第5和第6个字节\n"),t("ul",[t("li",[_._v("标识“技术预览版”功能特性的支持，一般不使用，全部固定为零")])])]),_._v(" "),t("li",[_._v("主版本号：第7和第8个字节\n"),t("ul",[t("li",[_._v("JDK向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，例如JDK8的版本号为52.0，JDK13的版本号为57，JDK13可以运行JDK8编译的Class文件，但是JDK8不能运行JDK13编译的Class文件")])])])]),_._v(" "),t("h4",{attrs:{id:"常量池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常量池"}},[_._v("#")]),_._v(" 常量池")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("是表数据类型，被喻为Class文件里的资源仓库")])]),_._v(" "),t("li",[t("p",[_._v("常量池主要存放俩大类常量：")]),_._v(" "),t("ul",[t("li",[_._v("字面量：文本字符串、被声明为final的常量值等")]),_._v(" "),t("li",[_._v("符号引用：字段名称和描述符、方法名称和描述符、类和接口的全限定名、方法句柄和方法类型等")])])]),_._v(" "),t("li",[t("p",[_._v("截止到JDK13，常量表中分别有17种不同类型的常量")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("类型")]),_._v(" "),t("th",[_._v("标志")]),_._v(" "),t("th",[_._v("描述")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("CONSTANT_Utf8_info")]),_._v(" "),t("td",[_._v("1")]),_._v(" "),t("td",[_._v("UTF-8")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_Integer_info")]),_._v(" "),t("td",[_._v("3")]),_._v(" "),t("td",[_._v("整型字面量")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_Float_info")]),_._v(" "),t("td",[_._v("4")]),_._v(" "),t("td",[_._v("浮点型字面量")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_Long_info")]),_._v(" "),t("td",[_._v("5")]),_._v(" "),t("td",[_._v("长整型字面量")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_Double_info")]),_._v(" "),t("td",[_._v("6")]),_._v(" "),t("td",[_._v("双精度浮点型字面量")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_Class_info")]),_._v(" "),t("td",[_._v("7")]),_._v(" "),t("td",[_._v("类或接口的符号引用")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_String_info")]),_._v(" "),t("td",[_._v("8")]),_._v(" "),t("td",[_._v("字符串类型字面量")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_Fieldref_info")]),_._v(" "),t("td",[_._v("9")]),_._v(" "),t("td",[_._v("字段的符号引用")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_Methodref_info")]),_._v(" "),t("td",[_._v("10")]),_._v(" "),t("td",[_._v("类中方法的符号引用")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_InterfaceMethodref_info")]),_._v(" "),t("td",[_._v("11")]),_._v(" "),t("td",[_._v("接口中方法的符号引用")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_NameAndType_info")]),_._v(" "),t("td",[_._v("12")]),_._v(" "),t("td",[_._v("字段或方法的部分符号引用")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_MethodHandle_info")]),_._v(" "),t("td",[_._v("15")]),_._v(" "),t("td",[_._v("表示方法句柄")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_MethodType_info")]),_._v(" "),t("td",[_._v("16")]),_._v(" "),t("td",[_._v("表示方法类型")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_Dynamic_info")]),_._v(" "),t("td",[_._v("17")]),_._v(" "),t("td",[_._v("表示一个动态计算量")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_InvokeDynamic_info")]),_._v(" "),t("td",[_._v("18")]),_._v(" "),t("td",[_._v("表示一个动态方法调用点")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_Module_info")]),_._v(" "),t("td",[_._v("19")]),_._v(" "),t("td",[_._v("表示一个模块")])]),_._v(" "),t("tr",[t("td",[_._v("CONSTANT_Package_info")]),_._v(" "),t("td",[_._v("20")]),_._v(" "),t("td",[_._v("表示一个模块中开放或者导出的包")])])])])])]),_._v(" "),t("h4",{attrs:{id:"访问标志"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问标志"}},[_._v("#")]),_._v(" 访问标志")]),_._v(" "),t("p",[_._v("在常量池结束后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：")]),_._v(" "),t("ul",[t("li",[_._v("这个Class是类还是接口")]),_._v(" "),t("li",[_._v("是否定义为public类型")]),_._v(" "),t("li",[_._v("是否为abstract类型")]),_._v(" "),t("li",[_._v("如果是类的话，是否被声明为final等")])]),_._v(" "),t("p",[_._v("具体的标志位以及含义：")]),_._v(" "),t("p",[_._v("access_flags中一共有16个标志位可以使用，当前只定义了9个")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("标志名称")]),_._v(" "),t("th",[_._v("标志值")]),_._v(" "),t("th",[_._v("含义")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("ACC_PUBLIC")]),_._v(" "),t("td",[_._v("0x0001")]),_._v(" "),t("td",[_._v("是否为public类型")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_FINAL")]),_._v(" "),t("td",[_._v("0x0010")]),_._v(" "),t("td",[_._v("是否被声明为final，只有类可设置")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_SUPER")]),_._v(" "),t("td",[_._v("0x0020")]),_._v(" "),t("td",[_._v("是否允许使用invokespecial字节码指令的新语义，"),t("br"),_._v("invokespecial指令的语义在JDK1.0.2发生过改变，"),t("br"),_._v("为了区别这条指令使用哪种语义，JDK1.0.2之后"),t("br"),_._v("编译出来的类的标志都必须为真")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_INTERFACE")]),_._v(" "),t("td",[_._v("0x0200")]),_._v(" "),t("td",[_._v("表示这是一个接口")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_ABSTRACT")]),_._v(" "),t("td",[_._v("0x0400")]),_._v(" "),t("td",[_._v("是否为abstract类型，对于接口或抽象类来说，"),t("br"),_._v("此标志值为真，其他类型值为假")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_SYNTHETIC")]),_._v(" "),t("td",[_._v("0x1000")]),_._v(" "),t("td",[_._v("标识这个类并非由用户代码产生的")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_ANNOTATION")]),_._v(" "),t("td",[_._v("0x2000")]),_._v(" "),t("td",[_._v("标识这是一个注解")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_ENUM")]),_._v(" "),t("td",[_._v("0x4000")]),_._v(" "),t("td",[_._v("标识这是一个枚举")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_MODULE")]),_._v(" "),t("td",[_._v("0x8000")]),_._v(" "),t("td",[_._v("标识这是一个模块")])])])]),_._v(" "),t("h4",{attrs:{id:"类索引、父类索引与接口索引集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类索引、父类索引与接口索引集合"}},[_._v("#")]),_._v(" 类索引、父类索引与接口索引集合")]),_._v(" "),t("p",[_._v("类索引（this_class）和父类索引（super_class）都是一个u2数据类型，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件由这三项数据来确定该类型的继承关系。")]),_._v(" "),t("ul",[t("li",[_._v("除了Java.lang.Object外，所有类的父类索引都不为0")]),_._v(" "),t("li",[_._v("接口顺序从左到右排列在接口索引集合中")]),_._v(" "),t("li",[_._v("类索引和父类索引用俩个u2类型的索引值表示，各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串")]),_._v(" "),t("li",[_._v("对于接口索引集合，入口的第一项u2数据类型的数据为几口计数器（interface_count），表示索引表的容量")])]),_._v(" "),t("h4",{attrs:{id:"字段表集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字段表集合"}},[_._v("#")]),_._v(" 字段表集合")]),_._v(" "),t("p",[_._v("字段表（field_info）用于描述接口或者类中声明的变量。字段包括类级别变量以及实例级别变量，但不包括在方法内部声明的局部变量。")]),_._v(" "),t("p",[_._v("字段表结构：")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("类型")]),_._v(" "),t("th",[_._v("名称")]),_._v(" "),t("th",[_._v("数量")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("u2")]),_._v(" "),t("td",[_._v("access_flags")]),_._v(" "),t("td",[_._v("1")])]),_._v(" "),t("tr",[t("td",[_._v("u2")]),_._v(" "),t("td",[_._v("name_index")]),_._v(" "),t("td",[_._v("1")])]),_._v(" "),t("tr",[t("td",[_._v("u2")]),_._v(" "),t("td",[_._v("descriptor_index")]),_._v(" "),t("td",[_._v("1")])]),_._v(" "),t("tr",[t("td",[_._v("u2")]),_._v(" "),t("td",[_._v("attributes_count")]),_._v(" "),t("td",[_._v("1")])]),_._v(" "),t("tr",[t("td",[_._v("attribute_info")]),_._v(" "),t("td",[_._v("attributes")]),_._v(" "),t("td",[_._v("attributes_count")])])])]),_._v(" "),t("p",[_._v("字段修饰符放在access_flags项目中，与类的access_flags非常类似，都是一个u2的数据类型，其中可以设置的标志位和含义如下：")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("标志名称")]),_._v(" "),t("th",[_._v("标志值")]),_._v(" "),t("th",[_._v("含义")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("ACC_PUBLIC")]),_._v(" "),t("td",[_._v("0x0001")]),_._v(" "),t("td",[_._v("字段是否public")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_PRIVATE")]),_._v(" "),t("td",[_._v("0x0002")]),_._v(" "),t("td",[_._v("字段是否private")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_PROTECTED")]),_._v(" "),t("td",[_._v("0x0004")]),_._v(" "),t("td",[_._v("字段是否protected")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_STATIC")]),_._v(" "),t("td",[_._v("0x0008")]),_._v(" "),t("td",[_._v("字段是否static")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_FINAL")]),_._v(" "),t("td",[_._v("0x0010")]),_._v(" "),t("td",[_._v("字段是否final")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_VOLATILE")]),_._v(" "),t("td",[_._v("0x0040")]),_._v(" "),t("td",[_._v("字段是否volatile")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_TRANSIENT")]),_._v(" "),t("td",[_._v("0x0080")]),_._v(" "),t("td",[_._v("字段是否transient")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_SYNTHETIC")]),_._v(" "),t("td",[_._v("0x1000")]),_._v(" "),t("td",[_._v("字段是否由编译器自动产生")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_ENUM")]),_._v(" "),t("td",[_._v("0x4000")]),_._v(" "),t("td",[_._v("是否是enum")])])])]),_._v(" "),t("p",[_._v("name_index和descriptor_index都是对常量池项的引用，分别代表字段的简单名称、字段和方法的描述符")]),_._v(" "),t("ul",[t("li",[_._v("全限定名：com/vczyh/TestClass")]),_._v(" "),t("li",[_._v("简单名称：没有类型和参数修饰的方法或者字段的名称")]),_._v(" "),t("li",[_._v("字段描述符：例如 D 表示double类型")]),_._v(" "),t("li",[_._v("方法描述符：例如"),t("code",[_._v("(I)Ljava/lang/String")]),_._v(" 表示 "),t("code",[_._v("String toStr(int a)")])])]),_._v(" "),t("p",[_._v("attribute_info和属性表有关，  descriptor_index后面会跟着一个属性表集合，用于存储一些额外信息，字段表可以在属性表中附加描述零至多项的额外信息")]),_._v(" "),t("h4",{attrs:{id:"方法表集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法表集合"}},[_._v("#")]),_._v(" 方法表集合")]),_._v(" "),t("p",[_._v("方法表（method_info）结构和字段表结构一样，但方法访问标志有所不同：")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("标志名称")]),_._v(" "),t("th",[_._v("标志值")]),_._v(" "),t("th",[_._v("含义")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("ACC_PUBLIC")]),_._v(" "),t("td",[_._v("0x0001")]),_._v(" "),t("td",[_._v("方法是否为public")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_PRIVATE")]),_._v(" "),t("td",[_._v("0x0002")]),_._v(" "),t("td",[_._v("方法是否为private")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_PROTECTED")]),_._v(" "),t("td",[_._v("0x0004")]),_._v(" "),t("td",[_._v("方法是否为protected")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_STATIC")]),_._v(" "),t("td",[_._v("0x0008")]),_._v(" "),t("td",[_._v("方法是否为static")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_FINAL")]),_._v(" "),t("td",[_._v("0x0010")]),_._v(" "),t("td",[_._v("方法是否为final")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_SYNCHRONIZED")]),_._v(" "),t("td",[_._v("0x0020")]),_._v(" "),t("td",[_._v("方法是否为synchronized")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_BRIDGE")]),_._v(" "),t("td",[_._v("0x0040")]),_._v(" "),t("td",[t("strong",[_._v("方法是不是由编译器产生的桥接方法")])])]),_._v(" "),t("tr",[t("td",[_._v("ACC_VARARGS")]),_._v(" "),t("td",[_._v("0x0080")]),_._v(" "),t("td",[_._v("方法是否接受不定参数")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_NATIVE")]),_._v(" "),t("td",[_._v("0x0100")]),_._v(" "),t("td",[_._v("方法是否为native")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_ABSTRACT")]),_._v(" "),t("td",[_._v("0x0400")]),_._v(" "),t("td",[_._v("方法是否为abstract")])]),_._v(" "),t("tr",[t("td",[_._v("ACC_STRICT")]),_._v(" "),t("td",[_._v("0x0800")]),_._v(" "),t("td",[t("strong",[_._v("方法是否为strictfp")])])]),_._v(" "),t("tr",[t("td",[_._v("ACC_SYNTHETIC")]),_._v(" "),t("td",[_._v("0x1000")]),_._v(" "),t("td",[_._v("方法是否由编译器自动产生")])])])]),_._v(" "),t("p",[_._v("方法中的代码存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目")]),_._v(" "),t("ul",[t("li",[_._v("父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息，但可能会出现由编译器自动添加的方法，最常见的便是**类构造器”"),t("code",[_._v("<clinit>")]),_._v("“"),t("strong",[_._v("方法和")]),_._v("实例构造器”"),t("code",[_._v("<init>")]),_._v("“**方法")])]),_._v(" "),t("h4",{attrs:{id:"属性表集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性表集合"}},[_._v("#")]),_._v(" 属性表集合")]),_._v(" "),t("p",[_._v("Class文件、字段表、方法表都可以携带自己的属性表（attribute_info）集合，以描述某些场景专有的信息")]),_._v(" "),t("p",[_._v("虚拟机规范预定义的属性：")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("属性名称")]),_._v(" "),t("th",[_._v("使用位置")]),_._v(" "),t("th",[_._v("含义")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("Code")]),_._v(" "),t("td",[_._v("方法表")]),_._v(" "),t("td",[_._v("Java代码编译成的字节码指令")])]),_._v(" "),t("tr",[t("td",[_._v("ConstantValue")]),_._v(" "),t("td",[_._v("字段表")]),_._v(" "),t("td",[_._v("由final关键字定义的常量值")])]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")]),_._v(" "),t("tr",[t("td"),_._v(" "),t("td"),_._v(" "),t("td")])])]),_._v(" "),t("h3",{attrs:{id:"字节码指令简介-todo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字节码指令简介-todo"}},[_._v("#")]),_._v(" 字节码指令简介  // TODO")]),_._v(" "),t("h4",{attrs:{id:"字节码与数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字节码与数据类型"}},[_._v("#")]),_._v(" 字节码与数据类型")]),_._v(" "),t("h4",{attrs:{id:"加载和存储指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#加载和存储指令"}},[_._v("#")]),_._v(" 加载和存储指令")]),_._v(" "),t("h4",{attrs:{id:"运算指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运算指令"}},[_._v("#")]),_._v(" 运算指令")]),_._v(" "),t("h4",{attrs:{id:"类型转换指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型转换指令"}},[_._v("#")]),_._v(" 类型转换指令")]),_._v(" "),t("h4",{attrs:{id:"对象创建与访问指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象创建与访问指令"}},[_._v("#")]),_._v(" 对象创建与访问指令")]),_._v(" "),t("h4",{attrs:{id:"控制转移指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制转移指令"}},[_._v("#")]),_._v(" 控制转移指令")]),_._v(" "),t("h4",{attrs:{id:"方法调用和返回指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法调用和返回指令"}},[_._v("#")]),_._v(" 方法调用和返回指令")]),_._v(" "),t("h4",{attrs:{id:"异常处理指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异常处理指令"}},[_._v("#")]),_._v(" 异常处理指令")]),_._v(" "),t("h4",{attrs:{id:"同步指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步指令"}},[_._v("#")]),_._v(" 同步指令")]),_._v(" "),t("p",[_._v("如果方法设置了synchronized标志，执行线程就要求先成功持有管程然后才执行方法，最后完成方法或非正常完成时释放管程。虚拟机的指令集中有monitorenter和monitorexit俩条指令来支持synchronized关键字的语义。")])])}),[],!1,null,null,null);v.default=a.exports}}]);