(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{516:function(v,_,t){"use strict";t.r(_);var r=t(4),a=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h3",{attrs:{id:"运行时数据区域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区域"}},[v._v("#")]),v._v(" 运行时数据区域")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("数据区")]),v._v(" "),t("th",[v._v("线程共享/线程隔离")]),v._v(" "),t("th",[v._v("异常")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("程序计数器")]),v._v(" "),t("td",[v._v("线程隔离")]),v._v(" "),t("td",[v._v("没有")])]),v._v(" "),t("tr",[t("td",[v._v("虚拟机栈")]),v._v(" "),t("td",[v._v("线程隔离")]),v._v(" "),t("td",[v._v("StackOverflowError和OutOfMemoryError")])]),v._v(" "),t("tr",[t("td",[v._v("本地方法栈")]),v._v(" "),t("td",[v._v("线程隔离")]),v._v(" "),t("td",[v._v("StackOverflowError和OutOfMemoryError")])]),v._v(" "),t("tr",[t("td",[v._v("方法区")]),v._v(" "),t("td",[v._v("线程共享")]),v._v(" "),t("td",[v._v("OutOfMemoryError")])]),v._v(" "),t("tr",[t("td",[v._v("堆")]),v._v(" "),t("td",[v._v("线程共享")]),v._v(" "),t("td",[v._v("OutOfMemoryError")])])])]),v._v(" "),t("h3",{attrs:{id:"程序计数器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器"}},[v._v("#")]),v._v(" 程序计数器")]),v._v(" "),t("ul",[t("li",[v._v("较小的内存空间")]),v._v(" "),t("li",[v._v("当前线程所执行字节码的行号指示器")]),v._v(" "),t("li",[v._v("分支、循环、跳转、异常处理、线程恢复依赖计数器")]),v._v(" "),t("li",[v._v("线程执行Java方法，计数器的记录是正在执行的虚拟机字节码指令的地址")]),v._v(" "),t("li",[v._v("线程执行Native方法，计数器的记录为空")]),v._v(" "),t("li",[v._v("唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域")])]),v._v(" "),t("h3",{attrs:{id:"java虚拟机栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java虚拟机栈"}},[v._v("#")]),v._v(" Java虚拟机栈")]),v._v(" "),t("ul",[t("li",[v._v("描述的是Java方法执行的内存模型")]),v._v(" "),t("li",[v._v("每个方法执行时会创建一个栈帧用于"),t("strong",[v._v("存储局部变量表")]),v._v("、"),t("strong",[v._v("操作数栈")]),v._v("、"),t("strong",[v._v("动态链接")]),v._v("、"),t("strong",[v._v("方法出")]),v._v("口等信息。")]),v._v(" "),t("li",[v._v("每个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出站的过程\n"),t("ul",[t("li",[v._v("局部变量存放了编译期可知的各种"),t("strong",[v._v("基本数据类型")]),v._v("(boolean、byte、char、short、int、float、long、double)、"),t("strong",[v._v("对象引用")]),v._v("(reference类型，它可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置)和"),t("strong",[v._v("returnAddress类型")]),v._v("(指向了一条字节码指令的地址)")]),v._v(" "),t("li",[v._v("64位的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个")]),v._v(" "),t("li",[v._v("局部变量表所需的内存在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小")])])]),v._v(" "),t("li",[v._v("线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError")]),v._v(" "),t("li",[v._v("虚拟机栈动态扩展时无法申请到足够的内存，抛出OutOfMemoryError")])]),v._v(" "),t("h3",{attrs:{id:"本地方法栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈"}},[v._v("#")]),v._v(" 本地方法栈")]),v._v(" "),t("ul",[t("li",[v._v("语虚拟机栈相似(Native方法)")]),v._v(" "),t("li",[v._v("虚拟机规范没有对本地方法栈进行强行规定")]),v._v(" "),t("li",[v._v("Sun HotSpot虚拟机把本地方法栈和虚拟机栈合二为一")]),v._v(" "),t("li",[v._v("会抛出StackOverflowError和OutOfMemoryError")])]),v._v(" "),t("h3",{attrs:{id:"java堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java堆"}},[v._v("#")]),v._v(" Java堆")]),v._v(" "),t("ul",[t("li",[v._v("存放对象实例以及数组，但随着JIT编译器的发展与逃逸分析技术逐渐成熟、栈上分配、标量替换优化技术使得前者没那么绝对")]),v._v(" "),t("li",[v._v("垃圾收集器管理的主要区域，因此也被称作GC堆")]),v._v(" "),t("li",[v._v("现在收集器基本都采用分代收集算法")]),v._v(" "),t("li",[v._v("可以分为：新生代和老年代")]),v._v(" "),t("li",[v._v("还可以细分为：Eden空间、From survivor、To Survivor空间")]),v._v(" "),t("li",[v._v("Java堆可能划分出多个线程私有的分配缓冲区(TLAB)，可以更快的分配内存和回收内存")]),v._v(" "),t("li",[v._v("Java堆可以是在物理不连续内存空间，只要逻辑上是连续的即可")])]),v._v(" "),t("h3",{attrs:{id:"方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[v._v("#")]),v._v(" 方法区")]),v._v(" "),t("ul",[t("li",[v._v("用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。")]),v._v(" "),t("li",[v._v("别名——非堆")]),v._v(" "),t("li",[v._v("HotSpot对方法区的实现是永久代，方便垃圾收集器可以像管理Java堆一样管理方法区")])]),v._v(" "),t("blockquote",[t("p",[v._v("JDK7的HotSpot中，已经把原本放在永久代的字符串常量池移出，JDK8的HotSpot中，已经放弃永久代，实现改成metaspace")])]),v._v(" "),t("h3",{attrs:{id:"运行时常量池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池"}},[v._v("#")]),v._v(" 运行时常量池")]),v._v(" "),t("ul",[t("li",[v._v("是方法区的一部分")]),v._v(" "),t("li",[v._v("用于存放编译期生成的各种字面量和符号引用")]),v._v(" "),t("li",[v._v("运行期间也可能将新的常量放入池中，例如String类的intern()方法")])]),v._v(" "),t("h3",{attrs:{id:"直接内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#直接内存"}},[v._v("#")]),v._v(" 直接内存")]),v._v(" "),t("ul",[t("li",[v._v("直接内存不是虚拟机运行时数据区的一部分")]),v._v(" "),t("li",[v._v("它可以使用Native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuff对象作为这块内存的引用进行操作，不受Java堆大小的限制，避免了在Java堆和Native堆中来回复制数据。")]),v._v(" "),t("li",[v._v("可能抛出OutOfMemoryError")])]),v._v(" "),t("h3",{attrs:{id:"对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[v._v("#")]),v._v(" 对象")]),v._v(" "),t("ul",[t("li",[v._v("对象创建\n"),t("ul",[t("li",[v._v("遇到new指令，首先检查指令的参数能否在常量池中定位到一个类的符号引用")]),v._v(" "),t("li",[v._v("检查符号引用代表的类是否已被加载、解析和初始化过，如果没有必须先执行相应的类加载过程")]),v._v(" "),t("li",[v._v("为对象分配内存，对象所需内存大小在类加载完后便可以确定\n"),t("ul",[t("li",[v._v("Java堆绝对规整(所有用过的内存都放在一边，空闲的内存放在另一边)，已分配内存的末尾放个指针，分配内存就是把指针向空闲区域移动对象大小距离，这种分配方式称为”指针碰撞“")]),v._v(" "),t("li",[v._v("Java堆不规整，虚拟机会维护一个列表，记录哪些内存可用，分配时从列表找出一块足够大的空间分配给实例，并更新列表记录，这种分配方式称为”空闲列表“")]),v._v(" "),t("li",[v._v("压缩整理功能可以使Java堆绝对规整")]),v._v(" "),t("li",[v._v("并发：正在给对象A分配内存，指针还没修改，对象B又使用原来的指针分配内存\n"),t("ul",[t("li",[v._v("措施一：CAS+失败重试")]),v._v(" "),t("li",[v._v("措施二：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(TLAB)，只有TLAB用完并分配新的TLAB时，才需要同步锁定，虚拟机是否使用TLAB可以通过-XX:+/-UseTLAB参数设定")])])])])]),v._v(" "),t("li",[v._v("内存分配完后，初始化为零值(不包括对象头)，这一步保证了对象实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值")]),v._v(" "),t("li",[v._v("设置对象头：哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄")]),v._v(" "),t("li",[v._v("执行 "),t("code",[v._v("<init>")]),v._v(" 方法，把对象按照程序员的意愿进行初始化")])])]),v._v(" "),t("li",[v._v("对象的内存布局：对象头、实例数据、对齐填充\n"),t("ul",[t("li",[v._v("对象头：运行时数据、类型指针\n"),t("ul",[t("li",[v._v("运行时数据：哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳，称为“Mark Word”")]),v._v(" "),t("li",[v._v("类型指针：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，并不是所有的虚拟机实现都在对象数据上保留类型指针，也就是查找对象的元数据信息不一定要通过对象本身。如果对象是数组，在对象头还必须有一块用于记录数组长度的数据，因为通过普通Java对象的元数据可以确定对象大小，但是通过数组的元数据不能确定数组大小")])])]),v._v(" "),t("li",[v._v("实例数据：真正的有效信息，也就是在代码中定义的各种类型的字段内容")]),v._v(" "),t("li",[v._v("对齐填充：不是必然存在，起着占位符的作用。HotSpot要求对象起始地址必须是8字节的整数倍，也就是对象的大小必须是8字节的整数倍")])])]),v._v(" "),t("li",[v._v("对象的访问定位：句柄和直接指针\n"),t("ul",[t("li",[v._v("使用句柄：Java堆会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址。优点是如果对象移动，只会修改句柄，reference不变")]),v._v(" "),t("li",[v._v("使用直接指针：reference中存储的直接就是对象地址。优点是速度快")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);